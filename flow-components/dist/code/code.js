!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.flowcomponent=t():e.flowcomponent=t()}(this,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>d});let r=!1;new Promise((e=>e())).then((()=>r=!0)),"undefined"!=typeof doNothing&&doNothing();const o=!0===r;class n extends Error{static isWrappedFlowError(e){return e instanceof n||e.name==n.name}constructor(e){super(e.message),this.orig_error=e,this.name=n.WrappedFlowErrorName}}n.WrappedFlowErrorName="WrappedFlowError_ae24";class s extends Error{get detail(){return this._detail}constructor(e){super(e.message),this.name=s.FlowErrorName,e.stack&&(this.stack=e.stack),this.type=e.type,this.code=e.code,this.summary=e.summary,this.parameters=e.parameters,this.category=e.category,this._detail=e.detail}static isFlowError(e){return e instanceof s||e.name==s.FlowErrorName}appendDetail(e){this._detail=this._detail?this._detail+" - "+e:e}}function a(e,t,r,o,n){return{processInstanceId:e,taskId:t,dataInstance:r,actionType:o,customType:n}}function i(e){const{workflow:t,client:r,server:o,wfe:n}=e;if(t)return function(e){return{type:"workflow",...e.context()||{action:void 0},constants:e.constantsWId,addActivity:async t=>{await e.addActivity(t)},openProcessbyLock:async t=>await(null==e?void 0:e.wfe.processContext.retrieveContext(t)),complete:async(t,r,o,n,s)=>{const i=a(t,r,o,n,s);return await(null==e?void 0:e.wfe.processContext.complete(i))},commit:async(t,r,o)=>{const n=a(t,r,o);return await(null==e?void 0:e.wfe.processContext.commit(n))},dataSearch:{searchQuery:async t=>await e.wfe.dataSearch.searchQuery(t)},file:{upload:async(t,r,o,n)=>await e.wfe.file.upload(t,r,o,n),delete:async(t,r)=>{await e.wfe.file.delete(t,r)}}}}(t);if(r)return{type:"client"};if(o)return{type:"server"};if(n){const e=n.wfExecutionContext(),{wfEngineOnUs:t,user:r}=e.getWfeOnUs(),{processInstance:o,dataInstance:s,lastAction:a}=t;return{type:"workflowEngine",processInstance:o,dataInstance:s,action:a,currentUser:r}}throw new Error("WTF: where are you executing this flow ???")}s.FlowErrorName="FlowRuntimeError_ae24";class c{static addPIToPI(e,t){return t.initiatorUnit=e.initiatorUnit,t.currentUnit=e.currentUnit,t.priority=e.priority,t.lastUpdateUser=e.lastUpdateUser,t.status=e.status,t.statusDescription=e.statusDescription,t}static addTaskToTask(e,t){return t.currentUnit=e.currentUnit,t.priority=e.priority,t.userId=e.userId,t.userName=e.userName,t}}const l=async function(){}.constructor,d=async e=>{const t=Object.create(null),r=e.flow.getWorkflow(),n=e.flow.getServer(),a=e.flow.getClient(),d={permanentStore:()=>({set:async(e,t)=>{if(a)throw new Error("Not Implemented: permanentStore is not implemented yet on client.");if(n)throw new Error("Not Implemented: permanentStore is not implemented yet on server.");if(!r)throw new Error("permanent store can be executed only on workflow environment");await r.workflowDb().permanentStore.set(e,t)},get:async e=>{if(a)throw new Error("Not Implemented: permanentStore is not implemented yet on client.");if(n)throw new Error("Not Implemented: permanentStore is not implemented yet on server.");if(!r)throw new Error("permanent store can be executed only on workflow environment");return await r.workflowDb().permanentStore.get(e)}}),getIncomingRequest:()=>{if(n)throw new Error("Not Implemented: server request is not implemented yet.");if(!r)throw new Error("request can only be used on SERVER or WORKFLOW");const e=r.getIncomingRequest(),t=e.headers.additionalHeaders?JSON.parse(e.headers.additionalHeaders):{};return Object.keys(t).forEach((r=>{e.headers[r]=t[r]})),delete e.headers.additionalHeaders,e},context:i({client:a,server:n,workflow:r}),input:e.msg.input,output:e.msg.output,vars:e.msg.vars,appendFlowInfo:t=>{e.msg.infoList=e.msg.infoList||[],e.msg.infoList.push(t)},createError:e=>new s(e),randomUUID:()=>crypto.randomUUID(),log:(e,...t)=>{if(!r)throw new Error("request can only be used on SERVER or WORKFLOW");r.log(e,...t)},getConstant:async e=>{if(!r)throw new Error("request can only be used on SERVER or WORKFLOW");return await r.getConstant(e)}};let p,u=!1;e.props.waitTillNext&&(p=function(e,t={}){let r,n,s;const a=e=>{s&&clearTimeout(s),s=setTimeout((()=>{n(new Error(`The operation has timed out. timeoutValue  : ${e}`))}),e)};return e&&a(e),{startTimer:a,promise:new Promise(((e,s)=>{var a;a=e,r=o&&t.fixSyncResolve?e=>setTimeout((()=>a(e))):a,n=s})),resolver:r,reject:n}}(),d.next=()=>{u||(u=!0,w(),p.resolver())},d.fail=e=>{u||(u=!0,p.reject(e))});let w=()=>e.flow.next();if("workflow"==d.context.type){const t=d.context,r=t.processInstance;t.processInstance=structuredClone(t.processInstance),w=()=>{t.processInstance&&r&&(c.addPIToPI(t.processInstance,r),t.processInstance.tasks.forEach((e=>{const t=r.tasks.find((t=>e.taskId==t.taskId));c.addTaskToTask(e,t)}))),e.flow.next()}}const m=function(e){return e.startsWith(";\r\n(async ()")?e.replace(/;\r\n\(async \(\)/g,";\r\nawait (async ()"):e.replace(/const x = "AWAIT HERE";\r\n/g,"await ")}(e.props.code),f=l("window","global","globalThis","flow","document","XMLHttpRequest","fetch","setInterval","navigator",m).apply(t,[t,t,t,d,void 0,void 0,void 0,void 0,void 0]);p?await p.promise:(await f,w())};return t})()));